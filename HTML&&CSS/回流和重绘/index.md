### 回流

什么是回流？

浏览器在构建完呈现树（渲染树）之后，呈现器便开始计算每个呈现树节点的大小和位置信息。第一次是布局 layout，后面再次计算就是回流 reflow 了。回流是递归进行的，从浏览器的根节点开始，依次遍历子节点，计算每个子节点的大小和位置信息。

### 重绘

什么是重绘？

当呈现树被绘制之后，我们就知道了每个节点是否是可见的，以及可见节点对应的几何信息（大小和位置），只需要将它们转化为屏幕上对应的像素即可，这就是浏览器的绘制阶段，也叫重绘阶段。

### 何时发生回流重绘？

回流这一阶段主要就是计算每个节点对应的几何信息，因此当页面节点的几何信息发生变化时，就需要回流。比如：

- 添加或者删除可见的 DOM 元素
- 元素的位置发生变化
- 元素的尺寸发生变化（包括外边距，内边距，边框，高度，宽度）
- 内容发生变化
- 页面一开的渲染
- 浏览器窗口尺寸的变化

**注意：回流一定伴随着重绘，但重绘不一定会回流。**

### 浏览器的优惠机制

由于回流是一件非常消耗资源的操作，因此大多数浏览器都会通过队列化去修改并批量执行来优化重排过程，到了一定时间或者到了阈值之后才会去清空队列。**但是当获取布局信息的操作的时候，浏览器会强制刷新队列。**。例如访问以下属性或者方法的时候：

- offsetTop、offsetLeft、offsetWidth、offsetHeight
- scrollTop、scrollLeft、scrollWidth、scrollHeight
- clientTop、clientLeft、clientWidth、clientHeight
- getComputedStyle()
- getBoundingClientRect

以上属性和方法都需要返回最新的布局信息，因此浏览器不得不清空队列，触发回流重绘来返回正确的值。因此，我们在修改样式的时候，**最好避免使用上面列出的属性，他们都会刷新渲染队列**。如果要使用它们，最好将值缓存起来。

### 如何减少回流和重绘

- 批量的操作 DOM

  1. 使元素脱离文档流
  2. 对其进行多次修改
  3. 将元素带回到文档中。

- 避免触发同步布局事件
- 对于复杂动画效果，使用绝对定位文档流
- CSS3 硬件加速（GPU 加速）
  **划重点：使用 css3 硬件加速，可以让 transform、opacity、filters 这些动画不会引起回流重绘 。但是对于动画的其它属性，比如 background-color 这些，还是会引起回流重绘的，不过它还是可以提升这些动画的性能。**

