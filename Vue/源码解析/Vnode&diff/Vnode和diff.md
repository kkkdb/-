# 为什么需要虚拟DOM

首先需要看一下真实DOM的渲染流程

## 真实DOM的渲染流程

所有浏览器的渲染引擎工作流程大致分为5步：创建`DOM`树 --> 创建`CSSOM`树 --> 构建`Render`树 --> 布局`layout` --> 绘制`painting`

那么，如果我们频繁的操作DOM，浏览器会从构建`DOM`树开始，从头到尾执行一遍流程。比如需要更新10次DOM节点，浏览器收到第一个请求后，并不知道还有9个请求，因此会马上执行第一遍流程。所以最终会走完10遍流程。这样，前9次都是无用功。因此，频繁操作DOM是一个非常耗费性能的操作。这时候，就需要虚拟DOM。

# 虚拟DOM

虚拟DOM其实就是一个JS对象。

虚拟DOM就是为了解决浏览器性能问题被提出来的。如上，如果有10次操作，虚拟DOM并不会立即操作DOM，而是将这10次操作的`diff`保存到JS对象上。最终将这个JS对象一次性`attach`到`DOM`树上，再进行后续操作，避免大量的无用功。

这个JS对象里面有很多属性。例如`tagName标签名,props属性,childrens子节点`等等。

当我们需要操作改变DOM的时候，并不是直接改变DOM，而是以一种新的虚拟DOM缓存起来。

然后去采用`diff`算法去比较两颗虚拟树。

采用的是`深度优先遍历`算法。

每一个节点都有自己的一个index.同层级的相同节点去比较。如果有差异就储存在一个补丁对象`patch`里.

差异可分为4种：`替换，重新排序，修改属性，修改文本`。

有了这个差异化的对象，最后根据这个对象，映射的去最终一次性的改变真实DOM。

